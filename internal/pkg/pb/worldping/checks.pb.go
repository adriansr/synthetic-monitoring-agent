// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: checks.proto

package worldping

import (
	context "context"
	fmt "fmt"

	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"

	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type HttpMethod int32

const (
	HttpMethod_GET     HttpMethod = 0
	HttpMethod_HEAD    HttpMethod = 1
	HttpMethod_POST    HttpMethod = 2
	HttpMethod_OPTIONS HttpMethod = 3
)

var HttpMethod_name = map[int32]string{
	0: "GET",
	1: "HEAD",
	2: "POST",
	3: "OPTIONS",
}

var HttpMethod_value = map[string]int32{
	"GET":     0,
	"HEAD":    1,
	"POST":    2,
	"OPTIONS": 3,
}

func (x HttpMethod) String() string {
	return proto.EnumName(HttpMethod_name, int32(x))
}

func (HttpMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{0}
}

type DnsRecordType int32

const (
	DnsRecordType_A     DnsRecordType = 0
	DnsRecordType_AAAA  DnsRecordType = 1
	DnsRecordType_CNAME DnsRecordType = 2
	DnsRecordType_MX    DnsRecordType = 3
	DnsRecordType_NS    DnsRecordType = 4
	DnsRecordType_PTR   DnsRecordType = 5
	DnsRecordType_SOA   DnsRecordType = 6
	DnsRecordType_SRV   DnsRecordType = 7
	DnsRecordType_TXT   DnsRecordType = 8
)

var DnsRecordType_name = map[int32]string{
	0: "A",
	1: "AAAA",
	2: "CNAME",
	3: "MX",
	4: "NS",
	5: "PTR",
	6: "SOA",
	7: "SRV",
	8: "TXT",
}

var DnsRecordType_value = map[string]int32{
	"A":     0,
	"AAAA":  1,
	"CNAME": 2,
	"MX":    3,
	"NS":    4,
	"PTR":   5,
	"SOA":   6,
	"SRV":   7,
	"TXT":   8,
}

func (x DnsRecordType) String() string {
	return proto.EnumName(DnsRecordType_name, int32(x))
}

func (DnsRecordType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{1}
}

type DnsProtocol int32

const (
	DnsProtocol_TCP DnsProtocol = 0
	DnsProtocol_UDP DnsProtocol = 1
)

var DnsProtocol_name = map[int32]string{
	0: "TCP",
	1: "UDP",
}

var DnsProtocol_value = map[string]int32{
	"TCP": 0,
	"UDP": 1,
}

func (x DnsProtocol) String() string {
	return proto.EnumName(DnsProtocol_name, int32(x))
}

func (DnsProtocol) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{2}
}

type IpVersion int32

const (
	IpVersion_Any IpVersion = 0
	IpVersion_V4  IpVersion = 1
	IpVersion_V6  IpVersion = 2
)

var IpVersion_name = map[int32]string{
	0: "Any",
	1: "V4",
	2: "V6",
}

var IpVersion_value = map[string]int32{
	"Any": 0,
	"V4":  1,
	"V6":  2,
}

func (x IpVersion) String() string {
	return proto.EnumName(IpVersion_name, int32(x))
}

func (IpVersion) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{3}
}

type ValidationMethod int32

const (
	ValidationMethod_Regex        ValidationMethod = 0
	ValidationMethod_IncludesText ValidationMethod = 1
	ValidationMethod_ExcludesText ValidationMethod = 2
	ValidationMethod_ExactMatch   ValidationMethod = 3
)

var ValidationMethod_name = map[int32]string{
	0: "Regex",
	1: "IncludesText",
	2: "ExcludesText",
	3: "ExactMatch",
}

var ValidationMethod_value = map[string]int32{
	"Regex":        0,
	"IncludesText": 1,
	"ExcludesText": 2,
	"ExactMatch":   3,
}

func (x ValidationMethod) String() string {
	return proto.EnumName(ValidationMethod_name, int32(x))
}

func (ValidationMethod) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{4}
}

type ValidationSeverity int32

const (
	ValidationSeverity_Warning  ValidationSeverity = 0
	ValidationSeverity_Critical ValidationSeverity = 1
)

var ValidationSeverity_name = map[int32]string{
	0: "Warning",
	1: "Critical",
}

var ValidationSeverity_value = map[string]int32{
	"Warning":  0,
	"Critical": 1,
}

func (x ValidationSeverity) String() string {
	return proto.EnumName(ValidationSeverity_name, int32(x))
}

func (ValidationSeverity) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{5}
}

type CreateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *CreateResponse) Reset()         { *m = CreateResponse{} }
func (m *CreateResponse) String() string { return proto.CompactTextString(m) }
func (*CreateResponse) ProtoMessage()    {}
func (*CreateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{0}
}
func (m *CreateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateResponse.Merge(m, src)
}
func (m *CreateResponse) XXX_Size() int {
	return m.Size()
}
func (m *CreateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_CreateResponse proto.InternalMessageInfo

type UpdateResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UpdateResponse) Reset()         { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()    {}
func (*UpdateResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{1}
}
func (m *UpdateResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UpdateResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UpdateResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UpdateResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UpdateResponse.Merge(m, src)
}
func (m *UpdateResponse) XXX_Size() int {
	return m.Size()
}
func (m *UpdateResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UpdateResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UpdateResponse proto.InternalMessageInfo

type DeleteResponse struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *DeleteResponse) Reset()         { *m = DeleteResponse{} }
func (m *DeleteResponse) String() string { return proto.CompactTextString(m) }
func (*DeleteResponse) ProtoMessage()    {}
func (*DeleteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{2}
}
func (m *DeleteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteResponse.Merge(m, src)
}
func (m *DeleteResponse) XXX_Size() int {
	return m.Size()
}
func (m *DeleteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteResponse proto.InternalMessageInfo

// Check represents a check.
//
// The "settings" field defines the type of check.
type Check struct {
	Id                   int64         `protobuf:"varint,1,opt,name=id,proto3" json:"id"`
	TennantId            int64         `protobuf:"varint,2,opt,name=tennantId,proto3" json:"tennant_id"`
	Frequency            int64         `protobuf:"varint,3,opt,name=frequency,proto3" json:"frequency"`
	Offset               int64         `protobuf:"varint,4,opt,name=offset,proto3" json:"offset"`
	Timeout              int64         `protobuf:"varint,5,opt,name=timeout,proto3" json:"timeout"`
	Enabled              bool          `protobuf:"varint,6,opt,name=enabled,proto3" json:"enabled"`
	Tags                 []string      `protobuf:"bytes,7,rep,name=tags,proto3" json:"tags"`
	Settings             CheckSettings `protobuf:"bytes,8,opt,name=settings,proto3" json:"settings"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *Check) Reset()         { *m = Check{} }
func (m *Check) String() string { return proto.CompactTextString(m) }
func (*Check) ProtoMessage()    {}
func (*Check) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{3}
}
func (m *Check) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Check) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Check.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Check) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Check.Merge(m, src)
}
func (m *Check) XXX_Size() int {
	return m.Size()
}
func (m *Check) XXX_DiscardUnknown() {
	xxx_messageInfo_Check.DiscardUnknown(m)
}

var xxx_messageInfo_Check proto.InternalMessageInfo

// CheckSettings provides the settings for exactly one type of check.
type CheckSettings struct {
	PingSettings         *PingSettings `protobuf:"bytes,12,opt,name=pingSettings,proto3" json:"ping_settings,omitempty"`
	HttpSettings         *HttpSettings `protobuf:"bytes,13,opt,name=httpSettings,proto3" json:"http_settings,omitempty"`
	DnsSettings          *DnsSettings  `protobuf:"bytes,14,opt,name=dnsSettings,proto3" json:"dns_settings,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *CheckSettings) Reset()         { *m = CheckSettings{} }
func (m *CheckSettings) String() string { return proto.CompactTextString(m) }
func (*CheckSettings) ProtoMessage()    {}
func (*CheckSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{4}
}
func (m *CheckSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CheckSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CheckSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CheckSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CheckSettings.Merge(m, src)
}
func (m *CheckSettings) XXX_Size() int {
	return m.Size()
}
func (m *CheckSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_CheckSettings.DiscardUnknown(m)
}

var xxx_messageInfo_CheckSettings proto.InternalMessageInfo

// PingSettings provides the settings for a ping check.
//
// "hostname" is the hostname to check.
// "ipVersion" is the IP version to use for name resolution.
//
// The "validation" field provides the validations to be performed on
// the result, for example, the ping time must be below a particular
// threshold.
type PingSettings struct {
	Hostname             string                `protobuf:"bytes,1,opt,name=hostname,proto3" json:"hostname"`
	IpVersion            IpVersion             `protobuf:"varint,2,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ip_version"`
	Validation           []PingCheckValidation `protobuf:"bytes,3,rep,name=validation,proto3" json:"validation"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *PingSettings) Reset()         { *m = PingSettings{} }
func (m *PingSettings) String() string { return proto.CompactTextString(m) }
func (*PingSettings) ProtoMessage()    {}
func (*PingSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{5}
}
func (m *PingSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingSettings.Merge(m, src)
}
func (m *PingSettings) XXX_Size() int {
	return m.Size()
}
func (m *PingSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_PingSettings.DiscardUnknown(m)
}

var xxx_messageInfo_PingSettings proto.InternalMessageInfo

// HttpSettings provides the settings for a HTTP check.
type HttpSettings struct {
	Url                  string                 `protobuf:"bytes,1,opt,name=url,proto3" json:"url"`
	Method               HttpMethod             `protobuf:"varint,2,opt,name=method,proto3,enum=worldping.HttpMethod" json:"method"`
	Headers              []string               `protobuf:"bytes,3,rep,name=headers,proto3" json:"headers"`
	Body                 string                 `protobuf:"bytes,4,opt,name=body,proto3" json:"body"`
	DownloadLimit        int64                  `protobuf:"varint,5,opt,name=downloadLimit,proto3" json:"download_limit"`
	IpVersion            IpVersion              `protobuf:"varint,6,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ip_version"`
	ValidateCert         bool                   `protobuf:"varint,7,opt,name=validateCert,proto3" json:"validate_cert"`
	Validation           []HttpCheckValidations `protobuf:"bytes,8,rep,name=validation,proto3" json:"validation"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *HttpSettings) Reset()         { *m = HttpSettings{} }
func (m *HttpSettings) String() string { return proto.CompactTextString(m) }
func (*HttpSettings) ProtoMessage()    {}
func (*HttpSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{6}
}
func (m *HttpSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpSettings.Merge(m, src)
}
func (m *HttpSettings) XXX_Size() int {
	return m.Size()
}
func (m *HttpSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpSettings.DiscardUnknown(m)
}

var xxx_messageInfo_HttpSettings proto.InternalMessageInfo

// DnsSettings provides the settings for a DNS check.
type DnsSettings struct {
	Name                 string               `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	RecordType           DnsRecordType        `protobuf:"varint,2,opt,name=recordType,proto3,enum=worldping.DnsRecordType" json:"record_type"`
	Server               string               `protobuf:"bytes,3,opt,name=server,proto3" json:"server"`
	IpVersion            IpVersion            `protobuf:"varint,4,opt,name=ipVersion,proto3,enum=worldping.IpVersion" json:"ip_version"`
	Protocol             DnsProtocol          `protobuf:"varint,5,opt,name=protocol,proto3,enum=worldping.DnsProtocol" json:"protocol"`
	Port                 int32                `protobuf:"varint,6,opt,name=port,proto3" json:"port"`
	Validation           []DNSCheckValidation `protobuf:"bytes,7,rep,name=validation,proto3" json:"validation"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *DnsSettings) Reset()         { *m = DnsSettings{} }
func (m *DnsSettings) String() string { return proto.CompactTextString(m) }
func (*DnsSettings) ProtoMessage()    {}
func (*DnsSettings) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{7}
}
func (m *DnsSettings) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsSettings) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsSettings.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsSettings) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsSettings.Merge(m, src)
}
func (m *DnsSettings) XXX_Size() int {
	return m.Size()
}
func (m *DnsSettings) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsSettings.DiscardUnknown(m)
}

var xxx_messageInfo_DnsSettings proto.InternalMessageInfo

type ResponseTimeValidation struct {
	Threshold            int32              `protobuf:"varint,1,opt,name=threshold,proto3" json:"threshold"`
	Severity             ValidationSeverity `protobuf:"varint,2,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *ResponseTimeValidation) Reset()         { *m = ResponseTimeValidation{} }
func (m *ResponseTimeValidation) String() string { return proto.CompactTextString(m) }
func (*ResponseTimeValidation) ProtoMessage()    {}
func (*ResponseTimeValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{8}
}
func (m *ResponseTimeValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResponseTimeValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResponseTimeValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResponseTimeValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResponseTimeValidation.Merge(m, src)
}
func (m *ResponseTimeValidation) XXX_Size() int {
	return m.Size()
}
func (m *ResponseTimeValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_ResponseTimeValidation.DiscardUnknown(m)
}

var xxx_messageInfo_ResponseTimeValidation proto.InternalMessageInfo

type HttpCheckValidations struct {
	HeaderValidation       *HttpHeaderValidation   `protobuf:"bytes,1,opt,name=headerValidation,proto3" json:"header_validation"`
	BodyValidation         *HttpBodyValidation     `protobuf:"bytes,2,opt,name=bodyValidation,proto3" json:"body_validation"`
	ResponseTimeValidation *ResponseTimeValidation `protobuf:"bytes,3,opt,name=responseTimeValidation,proto3" json:"response_time_validation"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *HttpCheckValidations) Reset()         { *m = HttpCheckValidations{} }
func (m *HttpCheckValidations) String() string { return proto.CompactTextString(m) }
func (*HttpCheckValidations) ProtoMessage()    {}
func (*HttpCheckValidations) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{9}
}
func (m *HttpCheckValidations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpCheckValidations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpCheckValidations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpCheckValidations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpCheckValidations.Merge(m, src)
}
func (m *HttpCheckValidations) XXX_Size() int {
	return m.Size()
}
func (m *HttpCheckValidations) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpCheckValidations.DiscardUnknown(m)
}

var xxx_messageInfo_HttpCheckValidations proto.InternalMessageInfo

type HttpHeaderValidation struct {
	Header               string             `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Method               ValidationMethod   `protobuf:"varint,2,opt,name=method,proto3,enum=worldping.ValidationMethod" json:"method"`
	Value                string             `protobuf:"bytes,3,opt,name=value,proto3" json:"value"`
	Severity             ValidationSeverity `protobuf:"varint,4,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *HttpHeaderValidation) Reset()         { *m = HttpHeaderValidation{} }
func (m *HttpHeaderValidation) String() string { return proto.CompactTextString(m) }
func (*HttpHeaderValidation) ProtoMessage()    {}
func (*HttpHeaderValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{10}
}
func (m *HttpHeaderValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpHeaderValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpHeaderValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpHeaderValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpHeaderValidation.Merge(m, src)
}
func (m *HttpHeaderValidation) XXX_Size() int {
	return m.Size()
}
func (m *HttpHeaderValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpHeaderValidation.DiscardUnknown(m)
}

var xxx_messageInfo_HttpHeaderValidation proto.InternalMessageInfo

type HttpBodyValidation struct {
	Header               string             `protobuf:"bytes,1,opt,name=header,proto3" json:"header"`
	Method               ValidationMethod   `protobuf:"varint,2,opt,name=method,proto3,enum=worldping.ValidationMethod" json:"method"`
	Value                string             `protobuf:"bytes,3,opt,name=value,proto3" json:"value"`
	Severity             ValidationSeverity `protobuf:"varint,4,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *HttpBodyValidation) Reset()         { *m = HttpBodyValidation{} }
func (m *HttpBodyValidation) String() string { return proto.CompactTextString(m) }
func (*HttpBodyValidation) ProtoMessage()    {}
func (*HttpBodyValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{11}
}
func (m *HttpBodyValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpBodyValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpBodyValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpBodyValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpBodyValidation.Merge(m, src)
}
func (m *HttpBodyValidation) XXX_Size() int {
	return m.Size()
}
func (m *HttpBodyValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpBodyValidation.DiscardUnknown(m)
}

var xxx_messageInfo_HttpBodyValidation proto.InternalMessageInfo

type DNSCheckValidation struct {
	TtlValidation          *DnsTtlValidation       `protobuf:"bytes,1,opt,name=ttlValidation,proto3" json:"ttl_validation"`
	TextValidation         *DnsTextValidation      `protobuf:"bytes,2,opt,name=textValidation,proto3" json:"text_validation"`
	HostValidation         *DnsHostValidation      `protobuf:"bytes,4,opt,name=hostValidation,proto3" json:"host_validation"`
	ResponseTimeValidation *ResponseTimeValidation `protobuf:"bytes,3,opt,name=responseTimeValidation,proto3" json:"response_time_validation"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *DNSCheckValidation) Reset()         { *m = DNSCheckValidation{} }
func (m *DNSCheckValidation) String() string { return proto.CompactTextString(m) }
func (*DNSCheckValidation) ProtoMessage()    {}
func (*DNSCheckValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{12}
}
func (m *DNSCheckValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DNSCheckValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DNSCheckValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DNSCheckValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DNSCheckValidation.Merge(m, src)
}
func (m *DNSCheckValidation) XXX_Size() int {
	return m.Size()
}
func (m *DNSCheckValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_DNSCheckValidation.DiscardUnknown(m)
}

var xxx_messageInfo_DNSCheckValidation proto.InternalMessageInfo

type DnsTtlValidation struct {
	// always less or equal
	Name                 string             `protobuf:"bytes,1,opt,name=name,proto3" json:"name"`
	Value                int32              `protobuf:"varint,2,opt,name=value,proto3" json:"value"`
	Severity             ValidationSeverity `protobuf:"varint,3,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DnsTtlValidation) Reset()         { *m = DnsTtlValidation{} }
func (m *DnsTtlValidation) String() string { return proto.CompactTextString(m) }
func (*DnsTtlValidation) ProtoMessage()    {}
func (*DnsTtlValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{13}
}
func (m *DnsTtlValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTtlValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTtlValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTtlValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTtlValidation.Merge(m, src)
}
func (m *DnsTtlValidation) XXX_Size() int {
	return m.Size()
}
func (m *DnsTtlValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTtlValidation.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTtlValidation proto.InternalMessageInfo

type DnsTextValidation struct {
	Method               ValidationMethod   `protobuf:"varint,1,opt,name=method,proto3,enum=worldping.ValidationMethod" json:"method"`
	Value                string             `protobuf:"bytes,2,opt,name=value,proto3" json:"value"`
	Severity             ValidationSeverity `protobuf:"varint,3,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DnsTextValidation) Reset()         { *m = DnsTextValidation{} }
func (m *DnsTextValidation) String() string { return proto.CompactTextString(m) }
func (*DnsTextValidation) ProtoMessage()    {}
func (*DnsTextValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{14}
}
func (m *DnsTextValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsTextValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsTextValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsTextValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsTextValidation.Merge(m, src)
}
func (m *DnsTextValidation) XXX_Size() int {
	return m.Size()
}
func (m *DnsTextValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsTextValidation.DiscardUnknown(m)
}

var xxx_messageInfo_DnsTextValidation proto.InternalMessageInfo

type DnsHostValidation struct {
	Host                 []string           `protobuf:"bytes,1,rep,name=host,proto3" json:"host"`
	Severity             ValidationSeverity `protobuf:"varint,2,opt,name=severity,proto3,enum=worldping.ValidationSeverity" json:"severity"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *DnsHostValidation) Reset()         { *m = DnsHostValidation{} }
func (m *DnsHostValidation) String() string { return proto.CompactTextString(m) }
func (*DnsHostValidation) ProtoMessage()    {}
func (*DnsHostValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{15}
}
func (m *DnsHostValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DnsHostValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DnsHostValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DnsHostValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DnsHostValidation.Merge(m, src)
}
func (m *DnsHostValidation) XXX_Size() int {
	return m.Size()
}
func (m *DnsHostValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_DnsHostValidation.DiscardUnknown(m)
}

var xxx_messageInfo_DnsHostValidation proto.InternalMessageInfo

type PingCheckValidation struct {
	ResponseTimeValidation *ResponseTimeValidation `protobuf:"bytes,1,opt,name=responseTimeValidation,proto3" json:"response_time_validation"`
	XXX_NoUnkeyedLiteral   struct{}                `json:"-"`
	XXX_unrecognized       []byte                  `json:"-"`
	XXX_sizecache          int32                   `json:"-"`
}

func (m *PingCheckValidation) Reset()         { *m = PingCheckValidation{} }
func (m *PingCheckValidation) String() string { return proto.CompactTextString(m) }
func (*PingCheckValidation) ProtoMessage()    {}
func (*PingCheckValidation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a921b63774164c1f, []int{16}
}
func (m *PingCheckValidation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PingCheckValidation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PingCheckValidation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PingCheckValidation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PingCheckValidation.Merge(m, src)
}
func (m *PingCheckValidation) XXX_Size() int {
	return m.Size()
}
func (m *PingCheckValidation) XXX_DiscardUnknown() {
	xxx_messageInfo_PingCheckValidation.DiscardUnknown(m)
}

var xxx_messageInfo_PingCheckValidation proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("worldping.HttpMethod", HttpMethod_name, HttpMethod_value)
	proto.RegisterEnum("worldping.DnsRecordType", DnsRecordType_name, DnsRecordType_value)
	proto.RegisterEnum("worldping.DnsProtocol", DnsProtocol_name, DnsProtocol_value)
	proto.RegisterEnum("worldping.IpVersion", IpVersion_name, IpVersion_value)
	proto.RegisterEnum("worldping.ValidationMethod", ValidationMethod_name, ValidationMethod_value)
	proto.RegisterEnum("worldping.ValidationSeverity", ValidationSeverity_name, ValidationSeverity_value)
	proto.RegisterType((*CreateResponse)(nil), "worldping.CreateResponse")
	proto.RegisterType((*UpdateResponse)(nil), "worldping.UpdateResponse")
	proto.RegisterType((*DeleteResponse)(nil), "worldping.DeleteResponse")
	proto.RegisterType((*Check)(nil), "worldping.Check")
	proto.RegisterType((*CheckSettings)(nil), "worldping.CheckSettings")
	proto.RegisterType((*PingSettings)(nil), "worldping.PingSettings")
	proto.RegisterType((*HttpSettings)(nil), "worldping.HttpSettings")
	proto.RegisterType((*DnsSettings)(nil), "worldping.DnsSettings")
	proto.RegisterType((*ResponseTimeValidation)(nil), "worldping.ResponseTimeValidation")
	proto.RegisterType((*HttpCheckValidations)(nil), "worldping.HttpCheckValidations")
	proto.RegisterType((*HttpHeaderValidation)(nil), "worldping.HttpHeaderValidation")
	proto.RegisterType((*HttpBodyValidation)(nil), "worldping.HttpBodyValidation")
	proto.RegisterType((*DNSCheckValidation)(nil), "worldping.DNSCheckValidation")
	proto.RegisterType((*DnsTtlValidation)(nil), "worldping.DnsTtlValidation")
	proto.RegisterType((*DnsTextValidation)(nil), "worldping.DnsTextValidation")
	proto.RegisterType((*DnsHostValidation)(nil), "worldping.DnsHostValidation")
	proto.RegisterType((*PingCheckValidation)(nil), "worldping.PingCheckValidation")
}

func init() { proto.RegisterFile("checks.proto", fileDescriptor_a921b63774164c1f) }

var fileDescriptor_a921b63774164c1f = []byte{
	// 1446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xdc, 0x58, 0x4f, 0x6f, 0xdc, 0x44,
	0x14, 0x5f, 0x7b, 0xff, 0xbf, 0xdd, 0x6c, 0xa7, 0xd3, 0x36, 0xdd, 0x26, 0x6d, 0x1c, 0x22, 0x90,
	0xa2, 0x50, 0x35, 0x52, 0x80, 0xf2, 0xe7, 0x02, 0xbb, 0x49, 0x68, 0x22, 0x91, 0x3f, 0x9d, 0xdd,
	0x86, 0xd2, 0xcb, 0xca, 0x59, 0x4f, 0x76, 0x2d, 0xbc, 0xf6, 0x62, 0x4f, 0xd2, 0x84, 0x0f, 0x81,
	0x84, 0xc4, 0x89, 0x0b, 0xfd, 0x0e, 0xbd, 0x73, 0xce, 0xb1, 0x42, 0xe2, 0x6a, 0x41, 0x11, 0x17,
	0x7f, 0x0a, 0x34, 0x33, 0xf6, 0xae, 0xed, 0x5d, 0x1a, 0x68, 0x10, 0x48, 0x5c, 0xec, 0x37, 0x6f,
	0xde, 0xfb, 0xcd, 0xf8, 0xbd, 0xdf, 0x9b, 0x19, 0x0f, 0x54, 0xbb, 0x7d, 0xda, 0xfd, 0xd2, 0xbb,
	0x37, 0x74, 0x1d, 0xe6, 0xe0, 0xf2, 0x53, 0xc7, 0xb5, 0x8c, 0xa1, 0x69, 0xf7, 0xe6, 0xb4, 0x9e,
	0xe3, 0xf4, 0x2c, 0xba, 0x2a, 0x3a, 0x0e, 0x8f, 0x8f, 0x56, 0x99, 0x39, 0xa0, 0x1e, 0xd3, 0x07,
	0x43, 0x69, 0x3b, 0x77, 0xbd, 0xe7, 0xf4, 0x1c, 0x21, 0xae, 0x72, 0x49, 0x6a, 0x97, 0x10, 0xd4,
	0xd6, 0x5d, 0xaa, 0x33, 0x4a, 0xa8, 0x37, 0x74, 0x6c, 0x8f, 0x72, 0xcd, 0xa3, 0xa1, 0x91, 0xd2,
	0x6c, 0x50, 0x8b, 0xc6, 0x34, 0x3f, 0xa9, 0x90, 0x5f, 0xe7, 0x13, 0xc1, 0xb3, 0xa0, 0x9a, 0x46,
	0x5d, 0x59, 0x54, 0x96, 0xb3, 0xcd, 0x42, 0xe0, 0x6b, 0xaa, 0x69, 0x10, 0xd5, 0x34, 0xf0, 0x5d,
	0x28, 0x33, 0x6a, 0xdb, 0xba, 0xcd, 0xb6, 0x8d, 0xba, 0x2a, 0xba, 0x6b, 0x81, 0xaf, 0x41, 0xa8,
	0xec, 0x98, 0x06, 0x19, 0x1b, 0xe0, 0xb7, 0xa1, 0x7c, 0xe4, 0xd2, 0xaf, 0x8e, 0xa9, 0xdd, 0x3d,
	0xab, 0x67, 0x85, 0xf5, 0x4c, 0xe0, 0x6b, 0x63, 0x25, 0x19, 0x8b, 0x78, 0x09, 0x0a, 0xce, 0xd1,
	0x91, 0x47, 0x59, 0x3d, 0x27, 0x2c, 0x21, 0xf0, 0xb5, 0x50, 0x43, 0xc2, 0x37, 0x7e, 0x0b, 0x8a,
	0xfc, 0xfb, 0x9d, 0x63, 0x56, 0xcf, 0x0b, 0xa3, 0x4a, 0xe0, 0x6b, 0x91, 0x8a, 0x44, 0x02, 0x37,
	0xa3, 0xb6, 0x7e, 0x68, 0x51, 0xa3, 0x5e, 0x58, 0x54, 0x96, 0x4b, 0xd2, 0x2c, 0x54, 0x91, 0x48,
	0xc0, 0xb7, 0x21, 0xc7, 0xf4, 0x9e, 0x57, 0x2f, 0x2e, 0x66, 0x97, 0xcb, 0xcd, 0x52, 0xe0, 0x6b,
	0xa2, 0x4d, 0xc4, 0x13, 0x7f, 0x0a, 0x25, 0x8f, 0x32, 0x66, 0xda, 0x3d, 0xaf, 0x5e, 0x5a, 0x54,
	0x96, 0x2b, 0x6b, 0xf5, 0x7b, 0xa3, 0xbc, 0xdc, 0x13, 0x61, 0x6a, 0x85, 0xfd, 0x4d, 0x74, 0xee,
	0x6b, 0x99, 0xc0, 0xd7, 0x46, 0x1e, 0x64, 0x24, 0x2d, 0xfd, 0xa0, 0xc2, 0x4c, 0xc2, 0x1a, 0x3f,
	0x86, 0x2a, 0xc7, 0x88, 0xda, 0xf5, 0xaa, 0x40, 0xbf, 0x19, 0x43, 0xdf, 0x8f, 0x75, 0x37, 0xe7,
	0x03, 0x5f, 0xbb, 0xc9, 0xd5, 0x9d, 0x08, 0xf3, 0xae, 0x33, 0x30, 0x19, 0x1d, 0x0c, 0xd9, 0x19,
	0x49, 0x20, 0x71, 0xe4, 0x3e, 0x63, 0xc3, 0x11, 0xf2, 0xcc, 0x04, 0xf2, 0x56, 0xac, 0x5b, 0x22,
	0x73, 0x87, 0xa9, 0xc8, 0x71, 0x24, 0xdc, 0x86, 0x8a, 0x61, 0x7b, 0x23, 0xe0, 0x9a, 0x00, 0x9e,
	0x8d, 0x01, 0x6f, 0x8c, 0x7b, 0x9b, 0x73, 0x81, 0xaf, 0xcd, 0x1a, 0xb6, 0x37, 0x0d, 0x36, 0x0e,
	0xf3, 0x51, 0xee, 0xfc, 0x99, 0xa6, 0x2c, 0xbd, 0x50, 0xa0, 0x1a, 0xff, 0x62, 0xbc, 0x0c, 0xa5,
	0xbe, 0xe3, 0x31, 0x5b, 0x1f, 0x50, 0xc1, 0xc1, 0x72, 0xb3, 0xca, 0x83, 0x1b, 0xe9, 0xc8, 0x48,
	0xc2, 0x4d, 0x28, 0x9b, 0xc3, 0x03, 0xea, 0x7a, 0xa6, 0x63, 0x0b, 0x3e, 0xd6, 0xd6, 0xae, 0xc7,
	0x26, 0xb5, 0x1d, 0xf5, 0x49, 0x96, 0x9a, 0xc3, 0xce, 0x89, 0x6c, 0x93, 0xb1, 0x1b, 0x26, 0x00,
	0x27, 0xba, 0x65, 0x1a, 0x3a, 0xe3, 0x20, 0xd9, 0xc5, 0xec, 0x72, 0x65, 0x6d, 0x21, 0x95, 0x0c,
	0x91, 0xc0, 0x83, 0x91, 0x55, 0x13, 0x87, 0x09, 0x8f, 0x79, 0x92, 0x98, 0xbc, 0xf4, 0x3c, 0x0b,
	0xd5, 0x78, 0xa8, 0xf1, 0x2d, 0xc8, 0x1e, 0xbb, 0x56, 0xf8, 0x35, 0xc5, 0xc0, 0xd7, 0x78, 0x93,
	0xf0, 0x07, 0xfe, 0x10, 0x0a, 0x03, 0xca, 0xfa, 0x8e, 0x11, 0x7e, 0xc0, 0x8d, 0x54, 0xba, 0x76,
	0x44, 0xa7, 0xac, 0x07, 0x69, 0x48, 0xc2, 0x37, 0x27, 0x7a, 0x9f, 0xea, 0x06, 0x75, 0x3d, 0x31,
	0xef, 0xb2, 0x24, 0x7a, 0xa8, 0x22, 0x91, 0xc0, 0x89, 0x7e, 0xe8, 0x18, 0x67, 0xa2, 0xb0, 0x42,
	0xa2, 0xf3, 0x36, 0x11, 0x4f, 0xfc, 0x01, 0xcc, 0x18, 0xce, 0x53, 0xdb, 0x72, 0x74, 0xe3, 0x33,
	0x73, 0x60, 0x46, 0xa5, 0x85, 0x03, 0x5f, 0xab, 0x45, 0x1d, 0x1d, 0x8b, 0xf7, 0x90, 0xa4, 0x61,
	0x32, 0xfa, 0x85, 0xd7, 0x8b, 0xfe, 0x7b, 0x50, 0x0d, 0xe3, 0x46, 0xd7, 0xa9, 0xcb, 0xea, 0x45,
	0x51, 0xb0, 0x57, 0x03, 0x5f, 0x9b, 0x89, 0xf4, 0x9d, 0x2e, 0x75, 0x19, 0x49, 0x98, 0xe1, 0x56,
	0x22, 0x69, 0x25, 0x91, 0x34, 0x2d, 0x15, 0xb8, 0x54, 0xd2, 0xbc, 0x0b, 0xb3, 0xf6, 0x6d, 0x16,
	0x2a, 0x31, 0x1e, 0xf3, 0xb8, 0xc5, 0x38, 0x28, 0xe2, 0x26, 0xf8, 0x27, 0x9e, 0x78, 0x1b, 0xc0,
	0xa5, 0x5d, 0xc7, 0x35, 0xda, 0x67, 0x43, 0x1a, 0xe6, 0xae, 0x9e, 0xac, 0x08, 0x32, 0xea, 0x6f,
	0x5e, 0x09, 0x7c, 0xad, 0x22, 0xed, 0x3b, 0xec, 0x6c, 0x48, 0x49, 0xcc, 0x99, 0xaf, 0x7d, 0x1e,
	0x75, 0x4f, 0xa8, 0x2b, 0x56, 0xc9, 0xb2, 0xcc, 0xb5, 0xd4, 0x90, 0xf0, 0x9d, 0x0c, 0x76, 0xee,
	0xf5, 0x82, 0xfd, 0x09, 0x94, 0xc4, 0xfe, 0xd0, 0x75, 0x2c, 0x91, 0xe5, 0x5a, 0xba, 0x84, 0xf7,
	0xc3, 0x5e, 0x59, 0x70, 0x91, 0x2d, 0x19, 0x49, 0x3c, 0x24, 0x43, 0xc7, 0x65, 0x22, 0xdb, 0x79,
	0x19, 0x12, 0xde, 0x26, 0xe2, 0x89, 0x1f, 0x26, 0xb2, 0x52, 0x14, 0x59, 0xb9, 0x13, 0x1f, 0x61,
	0xb7, 0xf5, 0x77, 0x2b, 0xe9, 0x1b, 0x05, 0x66, 0xa3, 0x0d, 0xaa, 0x6d, 0x0e, 0xe8, 0xd8, 0x95,
	0x6f, 0x2f, 0xac, 0xef, 0x52, 0xaf, 0xef, 0x58, 0x72, 0xaf, 0xca, 0xcb, 0xed, 0x65, 0xa4, 0x24,
	0x63, 0x11, 0x3f, 0xe0, 0xcb, 0xf9, 0x09, 0x75, 0x4d, 0x76, 0x16, 0xe6, 0x2a, 0x3e, 0xb1, 0x31,
	0x6a, 0x2b, 0x34, 0x92, 0x11, 0x88, 0x5c, 0xc8, 0x48, 0x5a, 0xfa, 0x59, 0x85, 0xeb, 0xd3, 0xd8,
	0x85, 0x0f, 0x01, 0xc9, 0x82, 0x1b, 0x2b, 0xc5, 0xac, 0x26, 0x89, 0xb9, 0x95, 0x32, 0x6b, 0xde,
	0x08, 0x7c, 0xed, 0xaa, 0x74, 0xee, 0xc4, 0xe2, 0x30, 0x81, 0x87, 0x9f, 0x40, 0x8d, 0xd7, 0x6c,
	0x6c, 0x04, 0x55, 0x8c, 0x70, 0x27, 0x35, 0x42, 0x33, 0x61, 0xd4, 0xbc, 0x16, 0xf8, 0xda, 0x15,
	0xee, 0x18, 0x47, 0x4f, 0x21, 0xe1, 0xa7, 0x30, 0xeb, 0x4e, 0x0d, 0xb4, 0x20, 0x65, 0x65, 0xed,
	0x8d, 0xd8, 0x18, 0xd3, 0x33, 0xd2, 0xbc, 0x1d, 0xf8, 0x5a, 0x3d, 0x02, 0xe9, 0xf0, 0xed, 0x38,
	0x3e, 0xe0, 0x9f, 0xc0, 0x87, 0xbb, 0xc0, 0xef, 0x8a, 0x8c, 0x6b, 0x3a, 0x38, 0xbc, 0x38, 0x64,
	0x1c, 0xc2, 0x3a, 0x14, 0xc5, 0x21, 0x35, 0x24, 0x7c, 0xe3, 0x8f, 0x53, 0x6b, 0xe8, 0xfc, 0xd4,
	0xdc, 0xbe, 0x62, 0x25, 0xd5, 0x20, 0x7f, 0xa2, 0x5b, 0xc7, 0x34, 0x2c, 0xc0, 0x72, 0xe0, 0x6b,
	0x52, 0x41, 0xe4, 0x2b, 0xc1, 0x9f, 0xdc, 0x65, 0xf8, 0xf3, 0x9b, 0x02, 0x78, 0x32, 0x45, 0xff,
	0xb7, 0xaf, 0x7c, 0x96, 0x05, 0x3c, 0x59, 0xed, 0xf8, 0x11, 0xcc, 0x30, 0x66, 0x4d, 0x14, 0xc8,
	0x7c, 0x72, 0x15, 0x6a, 0xc7, 0x4d, 0xe4, 0x46, 0xc4, 0x98, 0x15, 0xa7, 0x52, 0x12, 0x05, 0x7f,
	0x01, 0x35, 0x46, 0x4f, 0xd9, 0x44, 0x59, 0xdc, 0x4e, 0xe1, 0x26, 0x6c, 0x64, 0x55, 0x70, 0xbf,
	0x44, 0x55, 0x24, 0x81, 0x38, 0x34, 0x3f, 0x6d, 0xc4, 0xa0, 0x73, 0xd3, 0xa0, 0xb7, 0x12, 0x36,
	0x12, 0x9a, 0xfb, 0x25, 0xa0, 0x93, 0x40, 0xff, 0x75, 0xc1, 0x7d, 0xaf, 0x00, 0x4a, 0x07, 0xfb,
	0x82, 0x2d, 0x6f, 0xc4, 0x1f, 0x55, 0xac, 0xb6, 0xaf, 0xe6, 0x4f, 0xf6, 0x32, 0xfc, 0xf9, 0x51,
	0x81, 0xab, 0x13, 0x19, 0x8b, 0x15, 0x80, 0x72, 0xc9, 0x02, 0x50, 0xff, 0x42, 0x01, 0x5c, 0xea,
	0x03, 0xbe, 0x16, 0xf3, 0x4f, 0xd2, 0x82, 0x47, 0x97, 0x73, 0xa0, 0xae, 0x8c, 0xff, 0x38, 0x78,
	0x9b, 0x88, 0xe7, 0x3f, 0xb7, 0x45, 0x7d, 0xa7, 0xc0, 0xb5, 0x29, 0xa7, 0xd6, 0x57, 0x10, 0x4e,
	0xf9, 0x17, 0x08, 0xb7, 0x72, 0x1f, 0x60, 0x7c, 0x9e, 0xc5, 0x45, 0xc8, 0x3e, 0xd8, 0x6c, 0xa3,
	0x0c, 0x2e, 0x41, 0x6e, 0x6b, 0xb3, 0xb1, 0x81, 0x14, 0x2e, 0xed, 0xef, 0xb5, 0xda, 0x48, 0xc5,
	0x15, 0x28, 0xee, 0xed, 0xb7, 0xb7, 0xf7, 0x76, 0x5b, 0x28, 0xbb, 0xd2, 0x81, 0x99, 0xc4, 0x59,
	0x0a, 0xe7, 0x41, 0x69, 0x48, 0xc7, 0x46, 0xa3, 0xd1, 0x40, 0x0a, 0x2e, 0x43, 0x7e, 0x7d, 0xb7,
	0xb1, 0xb3, 0x89, 0x54, 0x5c, 0x00, 0x75, 0xe7, 0x31, 0xca, 0xf2, 0xf7, 0x6e, 0x0b, 0xe5, 0xf8,
	0x30, 0xfb, 0x6d, 0x82, 0xf2, 0x5c, 0x68, 0xed, 0x35, 0x50, 0x41, 0x08, 0xe4, 0x00, 0x15, 0xb9,
	0xd0, 0x7e, 0xdc, 0x46, 0xa5, 0x15, 0x4d, 0x1c, 0xfb, 0xa2, 0xb3, 0x8f, 0xd0, 0xaf, 0xef, 0xa3,
	0x0c, 0x17, 0x1e, 0x6d, 0xec, 0x23, 0x65, 0xe5, 0x4d, 0x28, 0x8f, 0xce, 0x57, 0x5c, 0xdb, 0xb0,
	0xcf, 0x50, 0x86, 0x0f, 0x71, 0xf0, 0x2e, 0x52, 0xc4, 0xfb, 0x3e, 0x52, 0x57, 0x1e, 0x02, 0x4a,
	0x93, 0x90, 0xcf, 0x8c, 0xd0, 0x1e, 0x3d, 0x45, 0x19, 0x8c, 0xa0, 0xba, 0x6d, 0x77, 0xad, 0x63,
	0x83, 0x0a, 0x5a, 0x23, 0x85, 0x6b, 0x36, 0x4f, 0x63, 0x1a, 0x15, 0xd7, 0x00, 0x36, 0x4f, 0xf5,
	0x2e, 0xdb, 0xd1, 0x59, 0xb7, 0x8f, 0xb2, 0x2b, 0xab, 0x80, 0x27, 0xf3, 0xce, 0xa3, 0xf3, 0xb9,
	0xee, 0xda, 0xa6, 0xdd, 0x43, 0x19, 0x5c, 0x85, 0xd2, 0xba, 0x6b, 0x32, 0xb3, 0xab, 0x5b, 0x48,
	0x59, 0x7b, 0xae, 0x40, 0x41, 0xa4, 0xdd, 0xc3, 0xef, 0x43, 0x41, 0xde, 0x01, 0x60, 0x94, 0xfe,
	0x71, 0x9d, 0xbb, 0x15, 0xd7, 0x24, 0x2f, 0x0a, 0x32, 0xdc, 0x51, 0x5e, 0x15, 0x5c, 0xe0, 0x98,
	0xba, 0x4f, 0x10, 0x8e, 0xf2, 0x46, 0xe1, 0x02, 0xc7, 0xd4, 0xb5, 0x43, 0xa6, 0x39, 0x7f, 0xfe,
	0xeb, 0x42, 0xe6, 0xfc, 0xe5, 0x82, 0xf2, 0xe2, 0xe5, 0x82, 0xf2, 0xcb, 0xcb, 0x05, 0xe5, 0xc9,
	0xf8, 0x0a, 0xe4, 0xb0, 0x20, 0x0e, 0x9f, 0xef, 0xfc, 0x11, 0x00, 0x00, 0xff, 0xff, 0x70, 0x55,
	0x20, 0x0d, 0x24, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChecksClient is the client API for Checks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChecksClient interface {
	// Create adds a new check using the specified configuration.
	Create(ctx context.Context, in *Check, opts ...grpc.CallOption) (*CreateResponse, error)
	// Update changes to specified check to match the new
	// configuration.
	Update(ctx context.Context, in *Check, opts ...grpc.CallOption) (*UpdateResponse, error)
	// Delete removes the specified check.
	//
	// Only the ID is used, the rest of the information is ignored.
	Delete(ctx context.Context, in *Check, opts ...grpc.CallOption) (*DeleteResponse, error)
}

type checksClient struct {
	cc *grpc.ClientConn
}

func NewChecksClient(cc *grpc.ClientConn) ChecksClient {
	return &checksClient{cc}
}

func (c *checksClient) Create(ctx context.Context, in *Check, opts ...grpc.CallOption) (*CreateResponse, error) {
	out := new(CreateResponse)
	err := c.cc.Invoke(ctx, "/worldping.Checks/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checksClient) Update(ctx context.Context, in *Check, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := c.cc.Invoke(ctx, "/worldping.Checks/Update", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *checksClient) Delete(ctx context.Context, in *Check, opts ...grpc.CallOption) (*DeleteResponse, error) {
	out := new(DeleteResponse)
	err := c.cc.Invoke(ctx, "/worldping.Checks/Delete", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChecksServer is the server API for Checks service.
type ChecksServer interface {
	// Create adds a new check using the specified configuration.
	Create(context.Context, *Check) (*CreateResponse, error)
	// Update changes to specified check to match the new
	// configuration.
	Update(context.Context, *Check) (*UpdateResponse, error)
	// Delete removes the specified check.
	//
	// Only the ID is used, the rest of the information is ignored.
	Delete(context.Context, *Check) (*DeleteResponse, error)
}

// UnimplementedChecksServer can be embedded to have forward compatible implementations.
type UnimplementedChecksServer struct {
}

func (*UnimplementedChecksServer) Create(ctx context.Context, req *Check) (*CreateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Create not implemented")
}
func (*UnimplementedChecksServer) Update(ctx context.Context, req *Check) (*UpdateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (*UnimplementedChecksServer) Delete(ctx context.Context, req *Check) (*DeleteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}

func RegisterChecksServer(s *grpc.Server, srv ChecksServer) {
	s.RegisterService(&_Checks_serviceDesc, srv)
}

func _Checks_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Check)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worldping.Checks/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Create(ctx, req.(*Check))
	}
	return interceptor(ctx, in, info, handler)
}

func _Checks_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Check)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worldping.Checks/Update",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Update(ctx, req.(*Check))
	}
	return interceptor(ctx, in, info, handler)
}

func _Checks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Check)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChecksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/worldping.Checks/Delete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChecksServer).Delete(ctx, req.(*Check))
	}
	return interceptor(ctx, in, info, handler)
}

var _Checks_serviceDesc = grpc.ServiceDesc{
	ServiceName: "worldping.Checks",
	HandlerType: (*ChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _Checks_Create_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Checks_Update_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Checks_Delete_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "checks.proto",
}

func (m *CreateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *UpdateResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UpdateResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UpdateResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *DeleteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	return len(dAtA) - i, nil
}

func (m *Check) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Check) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Check) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	{
		size, err := m.Settings.MarshalToSizedBuffer(dAtA[:i])
		if err != nil {
			return 0, err
		}
		i -= size
		i = encodeVarintChecks(dAtA, i, uint64(size))
	}
	i--
	dAtA[i] = 0x42
	if len(m.Tags) > 0 {
		for iNdEx := len(m.Tags) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Tags[iNdEx])
			copy(dAtA[i:], m.Tags[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.Tags[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Timeout != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Frequency != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Frequency))
		i--
		dAtA[i] = 0x18
	}
	if m.TennantId != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.TennantId))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CheckSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CheckSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CheckSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.DnsSettings != nil {
		{
			size, err := m.DnsSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	if m.HttpSettings != nil {
		{
			size, err := m.HttpSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x6a
	}
	if m.PingSettings != nil {
		{
			size, err := m.PingSettings.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x62
	}
	return len(dAtA) - i, nil
}

func (m *PingSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Validation) > 0 {
		for iNdEx := len(m.Validation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Hostname) > 0 {
		i -= len(m.Hostname)
		copy(dAtA[i:], m.Hostname)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Hostname)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Validation) > 0 {
		for iNdEx := len(m.Validation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if m.ValidateCert {
		i--
		if m.ValidateCert {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x30
	}
	if m.DownloadLimit != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.DownloadLimit))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Body) > 0 {
		i -= len(m.Body)
		copy(dAtA[i:], m.Body)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Body)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Headers) > 0 {
		for iNdEx := len(m.Headers) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Headers[iNdEx])
			copy(dAtA[i:], m.Headers[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.Headers[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Method != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Url) > 0 {
		i -= len(m.Url)
		copy(dAtA[i:], m.Url)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Url)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DnsSettings) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsSettings) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsSettings) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Validation) > 0 {
		for iNdEx := len(m.Validation) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Validation[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChecks(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Port != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x30
	}
	if m.Protocol != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Protocol))
		i--
		dAtA[i] = 0x28
	}
	if m.IpVersion != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.IpVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Server) > 0 {
		i -= len(m.Server)
		copy(dAtA[i:], m.Server)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Server)))
		i--
		dAtA[i] = 0x1a
	}
	if m.RecordType != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.RecordType))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResponseTimeValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResponseTimeValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResponseTimeValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x10
	}
	if m.Threshold != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Threshold))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HttpCheckValidations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpCheckValidations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpCheckValidations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResponseTimeValidation != nil {
		{
			size, err := m.ResponseTimeValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.BodyValidation != nil {
		{
			size, err := m.BodyValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HeaderValidation != nil {
		{
			size, err := m.HeaderValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpHeaderValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpHeaderValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpHeaderValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Method != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HttpBodyValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpBodyValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpBodyValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Method != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DNSCheckValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DNSCheckValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DNSCheckValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.HostValidation != nil {
		{
			size, err := m.HostValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.ResponseTimeValidation != nil {
		{
			size, err := m.ResponseTimeValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.TextValidation != nil {
		{
			size, err := m.TextValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TtlValidation != nil {
		{
			size, err := m.TtlValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DnsTtlValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTtlValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTtlValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x18
	}
	if m.Value != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Value))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DnsTextValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsTextValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsTextValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintChecks(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if m.Method != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Method))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DnsHostValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DnsHostValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DnsHostValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Severity != 0 {
		i = encodeVarintChecks(dAtA, i, uint64(m.Severity))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Host) > 0 {
		for iNdEx := len(m.Host) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Host[iNdEx])
			copy(dAtA[i:], m.Host[iNdEx])
			i = encodeVarintChecks(dAtA, i, uint64(len(m.Host[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *PingCheckValidation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PingCheckValidation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PingCheckValidation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ResponseTimeValidation != nil {
		{
			size, err := m.ResponseTimeValidation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChecks(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintChecks(dAtA []byte, offset int, v uint64) int {
	offset -= sovChecks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *CreateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *UpdateResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DeleteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Check) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovChecks(uint64(m.Id))
	}
	if m.TennantId != 0 {
		n += 1 + sovChecks(uint64(m.TennantId))
	}
	if m.Frequency != 0 {
		n += 1 + sovChecks(uint64(m.Frequency))
	}
	if m.Offset != 0 {
		n += 1 + sovChecks(uint64(m.Offset))
	}
	if m.Timeout != 0 {
		n += 1 + sovChecks(uint64(m.Timeout))
	}
	if m.Enabled {
		n += 2
	}
	if len(m.Tags) > 0 {
		for _, s := range m.Tags {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = m.Settings.Size()
	n += 1 + l + sovChecks(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CheckSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PingSettings != nil {
		l = m.PingSettings.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.HttpSettings != nil {
		l = m.HttpSettings.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.DnsSettings != nil {
		l = m.DnsSettings.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hostname)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	if len(m.Validation) > 0 {
		for _, e := range m.Validation {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Url)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovChecks(uint64(m.Method))
	}
	if len(m.Headers) > 0 {
		for _, s := range m.Headers {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	l = len(m.Body)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.DownloadLimit != 0 {
		n += 1 + sovChecks(uint64(m.DownloadLimit))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	if m.ValidateCert {
		n += 2
	}
	if len(m.Validation) > 0 {
		for _, e := range m.Validation {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsSettings) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.RecordType != 0 {
		n += 1 + sovChecks(uint64(m.RecordType))
	}
	l = len(m.Server)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.IpVersion != 0 {
		n += 1 + sovChecks(uint64(m.IpVersion))
	}
	if m.Protocol != 0 {
		n += 1 + sovChecks(uint64(m.Protocol))
	}
	if m.Port != 0 {
		n += 1 + sovChecks(uint64(m.Port))
	}
	if len(m.Validation) > 0 {
		for _, e := range m.Validation {
			l = e.Size()
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ResponseTimeValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Threshold != 0 {
		n += 1 + sovChecks(uint64(m.Threshold))
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpCheckValidations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HeaderValidation != nil {
		l = m.HeaderValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.BodyValidation != nil {
		l = m.BodyValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.ResponseTimeValidation != nil {
		l = m.ResponseTimeValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpHeaderValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovChecks(uint64(m.Method))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *HttpBodyValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Method != 0 {
		n += 1 + sovChecks(uint64(m.Method))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DNSCheckValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TtlValidation != nil {
		l = m.TtlValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.TextValidation != nil {
		l = m.TextValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.ResponseTimeValidation != nil {
		l = m.ResponseTimeValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.HostValidation != nil {
		l = m.HostValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsTtlValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Value != 0 {
		n += 1 + sovChecks(uint64(m.Value))
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsTextValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Method != 0 {
		n += 1 + sovChecks(uint64(m.Method))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *DnsHostValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Host) > 0 {
		for _, s := range m.Host {
			l = len(s)
			n += 1 + l + sovChecks(uint64(l))
		}
	}
	if m.Severity != 0 {
		n += 1 + sovChecks(uint64(m.Severity))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *PingCheckValidation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ResponseTimeValidation != nil {
		l = m.ResponseTimeValidation.Size()
		n += 1 + l + sovChecks(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovChecks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChecks(x uint64) (n int) {
	return sovChecks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (this *CheckSettings) GetValue() interface{} {
	if this.PingSettings != nil {
		return this.PingSettings
	}
	if this.HttpSettings != nil {
		return this.HttpSettings
	}
	if this.DnsSettings != nil {
		return this.DnsSettings
	}
	return nil
}

func (this *CheckSettings) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *PingSettings:
		this.PingSettings = vt
	case *HttpSettings:
		this.HttpSettings = vt
	case *DnsSettings:
		this.DnsSettings = vt
	default:
		return false
	}
	return true
}
func (this *HttpCheckValidations) GetValue() interface{} {
	if this.HeaderValidation != nil {
		return this.HeaderValidation
	}
	if this.BodyValidation != nil {
		return this.BodyValidation
	}
	if this.ResponseTimeValidation != nil {
		return this.ResponseTimeValidation
	}
	return nil
}

func (this *HttpCheckValidations) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *HttpHeaderValidation:
		this.HeaderValidation = vt
	case *HttpBodyValidation:
		this.BodyValidation = vt
	case *ResponseTimeValidation:
		this.ResponseTimeValidation = vt
	default:
		return false
	}
	return true
}
func (this *DNSCheckValidation) GetValue() interface{} {
	if this.TtlValidation != nil {
		return this.TtlValidation
	}
	if this.TextValidation != nil {
		return this.TextValidation
	}
	if this.ResponseTimeValidation != nil {
		return this.ResponseTimeValidation
	}
	if this.HostValidation != nil {
		return this.HostValidation
	}
	return nil
}

func (this *DNSCheckValidation) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *DnsTtlValidation:
		this.TtlValidation = vt
	case *DnsTextValidation:
		this.TextValidation = vt
	case *ResponseTimeValidation:
		this.ResponseTimeValidation = vt
	case *DnsHostValidation:
		this.HostValidation = vt
	default:
		return false
	}
	return true
}
func (this *PingCheckValidation) GetValue() interface{} {
	if this.ResponseTimeValidation != nil {
		return this.ResponseTimeValidation
	}
	return nil
}

func (this *PingCheckValidation) SetValue(value interface{}) bool {
	switch vt := value.(type) {
	case *ResponseTimeValidation:
		this.ResponseTimeValidation = vt
	default:
		return false
	}
	return true
}
func (m *CreateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UpdateResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UpdateResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UpdateResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Check) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Check: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Check: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TennantId", wireType)
			}
			m.TennantId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TennantId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Frequency", wireType)
			}
			m.Frequency = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Frequency |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tags", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tags = append(m.Tags, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Settings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Settings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CheckSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CheckSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CheckSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PingSettings == nil {
				m.PingSettings = &PingSettings{}
			}
			if err := m.PingSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HttpSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HttpSettings == nil {
				m.HttpSettings = &HttpSettings{}
			}
			if err := m.HttpSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DnsSettings", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DnsSettings == nil {
				m.DnsSettings = &DnsSettings{}
			}
			if err := m.DnsSettings.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validation = append(m.Validation, PingCheckValidation{})
			if err := m.Validation[len(m.Validation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Url", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Url = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= HttpMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Headers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Headers = append(m.Headers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Body", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Body = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DownloadLimit", wireType)
			}
			m.DownloadLimit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DownloadLimit |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidateCert", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ValidateCert = bool(v != 0)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validation = append(m.Validation, HttpCheckValidations{})
			if err := m.Validation[len(m.Validation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsSettings) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsSettings: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsSettings: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecordType", wireType)
			}
			m.RecordType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecordType |= DnsRecordType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Server", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Server = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpVersion", wireType)
			}
			m.IpVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IpVersion |= IpVersion(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Protocol", wireType)
			}
			m.Protocol = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Protocol |= DnsProtocol(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Validation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Validation = append(m.Validation, DNSCheckValidation{})
			if err := m.Validation[len(m.Validation)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResponseTimeValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResponseTimeValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResponseTimeValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Threshold", wireType)
			}
			m.Threshold = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Threshold |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpCheckValidations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpCheckValidations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpCheckValidations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HeaderValidation == nil {
				m.HeaderValidation = &HttpHeaderValidation{}
			}
			if err := m.HeaderValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.BodyValidation == nil {
				m.BodyValidation = &HttpBodyValidation{}
			}
			if err := m.BodyValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimeValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTimeValidation == nil {
				m.ResponseTimeValidation = &ResponseTimeValidation{}
			}
			if err := m.ResponseTimeValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpHeaderValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpHeaderValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpHeaderValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ValidationMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpBodyValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpBodyValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpBodyValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ValidationMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DNSCheckValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DNSCheckValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DNSCheckValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TtlValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TtlValidation == nil {
				m.TtlValidation = &DnsTtlValidation{}
			}
			if err := m.TtlValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TextValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TextValidation == nil {
				m.TextValidation = &DnsTextValidation{}
			}
			if err := m.TextValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimeValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTimeValidation == nil {
				m.ResponseTimeValidation = &ResponseTimeValidation{}
			}
			if err := m.ResponseTimeValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HostValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HostValidation == nil {
				m.HostValidation = &DnsHostValidation{}
			}
			if err := m.HostValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsTtlValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsTtlValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsTtlValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			m.Value = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Value |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsTextValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsTextValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsTextValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			m.Method = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Method |= ValidationMethod(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DnsHostValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DnsHostValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DnsHostValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = append(m.Host, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Severity", wireType)
			}
			m.Severity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Severity |= ValidationSeverity(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PingCheckValidation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PingCheckValidation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PingCheckValidation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResponseTimeValidation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChecks
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChecks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ResponseTimeValidation == nil {
				m.ResponseTimeValidation = &ResponseTimeValidation{}
			}
			if err := m.ResponseTimeValidation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChecks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthChecks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChecks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChecks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChecks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChecks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChecks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChecks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChecks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChecks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChecks = fmt.Errorf("proto: unexpected end of group")
)
